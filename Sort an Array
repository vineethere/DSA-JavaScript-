//https://neetcode.io/problems/sort-an-array?list=neetcode250

// Bubble Sort
class Solution {
    /**
     * @param {number[]} nums
     * @return {number[]}
     */
    sortArray(nums) {
        let n=nums.length;
        for(let i=0;i<n;i++){
            for(let j=0;j<n-i-1;j++){
                if(nums[j] > nums[j+1]){
                    [nums[j],nums[j+1]] = [nums[j+1],nums[j]];
                }
            }
        }
        return nums;
    }
}
Time complexity O(n)
Space complexity O(1) as it is not using any auxillary space


//selection sort
// O(n^2) time complexity O(1)space
class Solution {
    /**
     * @param {number[]} nums
     * @return {number[]}
     */
    sortArray(nums) {
        let n=nums.length;
        for(let i=0;i<n;i++){
          let minElement=nums[i];
          let minIndex=i;
            for(let j=i+1;j<n;j++){
                if(minElement>nums[j]){
                  minElement=nums[j];
                  minIndex=j;
                }
            }
            if(i!==minIndex){
            [nums[i] , nums[minIndex]] = [nums[minIndex] , nums[i]];
            }
        }
        return nums;
    }
}

//Merge Sort
ðŸ•’ Time Complexity
Best Case	O(n log n)
Average	    O(n log n)
Worst Case	O(n log n)
Space O(n)


class Solution {
    /**
     * @param {number[]} nums
     * @return {number[]}
     */
      mergeSort(nums,start,end){
        console.log(start,end);
        if(start>=end)return;
        let mid = Math.floor((start + end) / 2);
         this.mergeSort(nums,start,mid);
         this.mergeSort(nums,mid+1,end);
         let i=start,j=mid+1,res=[];
         while(i<=mid && j<=end){
            if(nums[i]<nums[j]){
              res.push(nums[i]);i++;
            }
            else{
              res.push(nums[j]);j++;
            }
         }
         while(i<=mid){
          res.push(nums[i]);i++;
         }
         while( j<=end){
           res.push(nums[j]);j++;
         }
        //  nums=JSON.parse(JSON.stringify(res));
        for(let k=0;k<res.length;k++){
            nums[start+k]=res[k];
        }
        //  nums=res;
         console.log("begin",nums,"  ", res,"end");
     }
    sortArray(nums) {
      let end=nums.length-1;
      let start=0;
      this.mergeSort(nums,start,end);
      return nums;
    }
}


//Quick Sort Arrays
class Solution {
    /**
     * @param {number[]} nums
     * @return {number[]}
     */
    partition = (nums,start,end) =>{
        let pivot = nums[Math.floor((start+end)/2)];
        
        while(start<=end){
            while(nums[start]<pivot)start++;
            while(nums[end]>pivot)end--;
             if (start <= end) {
                [nums[start],nums[end]] = [nums[end],nums[start]];
                start++;end--;
            }
      }
      return start;
    }
    quickSort(nums,start,end){
        if(start>=end)return;
        let pivot = this.partition(nums,start,end);
        this.quickSort(nums,start,pivot-1);
        this.quickSort(nums,pivot,end);
    }
    sortArray(nums) {
        if (!nums || nums.length === 0) return [];
        this.quickSort(nums,0,nums?.length-1);
        return nums;
    }
}
Algorithm	Time Complexity   	Space Complexity (Worst Case)
Quick Sort  	O(N log N)	       O(N)
